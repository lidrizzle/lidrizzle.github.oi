<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lidrizzle&#39;s Blog</title>
  
  <subtitle>内心丰盈者，独行也出众</subtitle>
  <link href="https://lidrizzle.github.io/lidrizzle.github.oi/atom.xml" rel="self"/>
  
  <link href="https://lidrizzle.github.io/lidrizzle.github.oi/"/>
  <updated>2024-05-27T15:18:28.614Z</updated>
  <id>https://lidrizzle.github.io/lidrizzle.github.oi/</id>
  
  <author>
    <name>Lidrizzle</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>贪心问题</title>
    <link href="https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/27/%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98/%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98/"/>
    <id>https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/27/%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98/%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98/</id>
    <published>2024-05-27T15:16:16.000Z</published>
    <updated>2024-05-27T15:18:28.614Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\lidrizzle.github.oi\assets\css\APlayer.min.css"><script src="\lidrizzle.github.oi\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\lidrizzle.github.oi\assets\js\Meting.min.js"></script><h1 id="区间贪心"><a href="#区间贪心" class="headerlink" title="区间贪心"></a>区间贪心</h1><h4 id="1-区间合并"><a href="#1-区间合并" class="headerlink" title="1.区间合并"></a>1.区间合并</h4><p>步骤：</p><blockquote><ol><li>将区间按照<em><strong>左端点</strong></em>升序排序</li><li>从第一个区间开始，如果该区间的右端点大于后面相邻区间的左端点，当前区间右端点更新为：</li><li>ed &#x3D; max(ed, x.second);</li><li>直到不能合并，然后开始后面区间合并</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;PII&gt; <span class="title">merge</span><span class="params">(vector&lt;PII&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    vector&lt;PII&gt; segs;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">//默认按照第一个元素升序排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed =  <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x :v) &#123;</span><br><span class="line">        <span class="comment">// 两种情况：可以合并、不可以合并、</span></span><br><span class="line">        <span class="comment">//如果不可以合并，且不是初始的区间（-2e9, 2e9），保存，并开辟下一区间</span></span><br><span class="line">        <span class="comment">//如果可合并，更新右端点</span></span><br><span class="line">        <span class="keyword">if</span> (x.first &gt; ed) &#123; <span class="comment">// 不能合并，开辟下一个区间</span></span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) &#123; </span><br><span class="line">                segs.<span class="built_in">push_back</span>(&#123;st, ed&#125;); <span class="comment">//将当前合并过的大区间放入数组</span></span><br><span class="line">            <span class="comment">//根据题目要求增加操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            st = x.first, ed = x.second; <span class="comment">//将区间做右端点都更新为下一区间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, x.second); <span class="comment">// 可以合并，就更新右端点为最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) segs.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line"><span class="keyword">return</span> segs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-区间选点"><a href="#2-区间选点" class="headerlink" title="2.区间选点"></a>2.区间选点</h4><p>*** 右端点排序***</p><p>同类型的问题有：</p><ul><li>最大不相交区间数量</li><li>活动安排</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(PII &amp;a, PII b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;PII&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> l, r; cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        v[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; v[i].first) cnt ++, ed = v[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (T -- ) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-区间覆盖"><a href="#3-区间覆盖" class="headerlink" title="3.区间覆盖"></a>3.区间覆盖</h4><p>*** 左端点排序***</p><p>给出目标区间[st, ed]，用最少区间去覆盖掉它</p><p>例题：一本通的《草坪浇灌》</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> l, r; cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    v[i] = &#123;l, r&#125;;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> st = <span class="number">0</span>, ed = L;</span><br><span class="line">    <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> j = i, r = -INF;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; v[i].x &lt;= st) &#123;</span><br><span class="line">            r = <span class="built_in">max</span>(r, v[i].y);</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; st) &#123;</span><br><span class="line">            cnt = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt ++; </span><br><span class="line">        <span class="keyword">if</span> (r &gt;= ed) &#123;</span><br><span class="line">            ok = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        st = r;</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ok == <span class="literal">false</span>) cnt = <span class="number">-1</span>;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-区间分组-教室安排活动"><a href="#4-区间分组-教室安排活动" class="headerlink" title="4.区间分组(教室安排活动)"></a>4.区间分组(教室安排活动)</h4><p>题目大意：有N个区间请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。</p><p>例题：有若干个活动，活动开始结束区间为[l, r],同一个教室安排的活动之间不能交叠，求要安排所有活动，少需要几个教室？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//y总</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;PII&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        v[i] = &#123;l, r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">        <span class="comment">// 前面所有组的最小右端点 &gt;= 当前区间的左端点，证明一定没有组可以放，所有组都有交集，要再新开一个组</span></span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">empty</span>() || q.<span class="built_in">top</span>() &gt;= v[i].first) q.<span class="built_in">push</span>(v[i].second); <span class="comment">// &gt;= 想等也算相交</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 因为堆里存储的是每个组的最大右端点，else说明q.top()这个组的最大右端点将会来一个更大的右端点</span></span><br><span class="line">            <span class="comment">// ，所以小的要退位，更大的右端点上位了</span></span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(v[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T -- ) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 7 9</span></span><br><span class="line"><span class="comment">// -4 6</span></span><br><span class="line"><span class="comment">// -4 -2</span></span><br><span class="line"><span class="comment">// -6 0</span></span><br><span class="line"><span class="comment">// -7 6</span></span><br><span class="line"><span class="comment">// 1 6</span></span><br><span class="line"><span class="comment">// -9 6</span></span><br><span class="line"><span class="comment">// -5 -3</span></span><br><span class="line"><span class="comment">// 2 10</span></span><br><span class="line"><span class="comment">// -10 6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AcWing 《i同学》思路</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> b[<span class="number">2</span> * N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        b[idx ++] = l * <span class="number">2</span>;<span class="comment">//标记左端点为偶数。</span></span><br><span class="line">        b[idx ++] = r * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">// 标记右端点为奇数。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(b, b + idx);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i] % <span class="number">2</span> == <span class="number">0</span>) t ++;</span><br><span class="line">        <span class="keyword">else</span> t --;</span><br><span class="line">        res = <span class="built_in">max</span>(res, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>未完待续….</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;lidrizzle.github.oi&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;lidrizzle</summary>
      
    
    
    
    
    <category term="Greedy" scheme="https://lidrizzle.github.io/lidrizzle.github.oi/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>数论</title>
    <link href="https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/27/%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA/"/>
    <id>https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/27/%E6%95%B0%E8%AE%BA/%E6%95%B0%E8%AE%BA/</id>
    <published>2024-05-27T15:13:29.000Z</published>
    <updated>2024-05-27T15:15:40.309Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\lidrizzle.github.oi\assets\css\APlayer.min.css"><script src="\lidrizzle.github.oi\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\lidrizzle.github.oi\assets\js\Meting.min.js"></script><h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h3 id="1-位运算"><a href="#1-位运算" class="headerlink" title="1.  位运算"></a>1.  位运算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取整数n的二进制第k位数 或者说判断整数n二进制第k位是0还是1</span></span><br><span class="line">n &gt;&gt; k &amp; <span class="number">1</span>;</span><br><span class="line"><span class="number">1</span>的二进制中只有第<span class="number">0</span>位是<span class="number">1</span>，当任意一个数x与<span class="number">1</span>做&amp;运算时，无论x二进制数&gt;=<span class="number">1</span>上的数是多少，与<span class="number">1</span>的二进制数&gt;=<span class="number">1</span>的数做与（&amp;）运算都是<span class="number">0</span>，因为<span class="number">1</span>的二进制位数&gt;=<span class="number">1</span>是，其上的数都是<span class="number">0</span>，所以要判断n的二进制第k位数是<span class="number">0</span>还是<span class="number">1</span>时，只需要将n的第k二进制第k位移动到第<span class="number">0</span>位，再与<span class="number">1</span>做与（&amp;）运算就可得出结果。</span><br></pre></td></tr></table></figure><h3 id="2-取模的运算性质"><a href="#2-取模的运算性质" class="headerlink" title="2.取模的运算性质"></a>2.取模的运算性质</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(a + b) % p = (a % p + b % p) % p;</span><br><span class="line"></span><br><span class="line">(a - b) % p = (a % p - b % p) % p;</span><br><span class="line"></span><br><span class="line">(a * b) % p = (a % p * b % p) % p;</span><br><span class="line"></span><br><span class="line">a ^ b % p = ((a % p)^b) % p;</span><br></pre></td></tr></table></figure><h3 id="3-快速幂"><a href="#3-快速幂" class="headerlink" title="3.快速幂"></a>3.快速幂</h3><p>a ^ n &#x3D; a * a * a* a* …a * a * a，暴力的计算复杂度为O(n)</p><p><strong>对于a 的n次方，我们只需要log(n) + 1次（n的二进制位数）运算即可，复杂度由O(n) —&gt; O(logn)</strong></p><p>给定n组a, b, p，对于每组数据，求出 a ^ b mod p 的值</p><blockquote><p>快速幂使用二进制拆分和倍增的思想</p><p>快速幂可以应用在任何具有结合律的运算</p><p>时间复杂度O(logn)</p></blockquote><p>(3 ^ 13) % p  &#x3D; ((3 ^ 8) % p) * (3 ^ 4) % p * (3 ^ 1) % p) % p;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p的范围：1 &lt;= p &lt;= 10^200000</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;<span class="comment">//对b进行二进制化,从低位到高位</span></span><br><span class="line">        <span class="comment">//b&amp;1就是判断b的二进制表示中第0位上的数是否为1,若为1,b&amp;1=true,反之b&amp;1=false;b&amp;1也可以用来判断奇数和偶数,b&amp;1=true时为奇数,反之b&amp;1=false时为偶数</span></span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = (LL) res * a % p;<span class="comment">//如果b的二进制表示的第0(最右边的位,即末位)位为1,则乘上当前的a</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span> ;<span class="comment">//b右移一位</span></span><br><span class="line">        a = (LL) a * a % p;<span class="comment">//更新a,a依次为a^&#123;2^0&#125;,a^&#123;2^1&#125;,a^&#123;2^2&#125;,....,a^&#123;2^logb&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t -- ) &#123; </span><br><span class="line">        <span class="type">int</span> a, p; string b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) &#123;</span><br><span class="line">            ans =(LL)ans * <span class="built_in">qmi</span>(a, b[i] - <span class="string">&#x27;0&#x27;</span>, p) % p;</span><br><span class="line">            a = (LL)<span class="built_in">qmi</span>(a, <span class="number">10</span>, p) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-最大公约数"><a href="#4-最大公约数" class="headerlink" title="4. 最大公约数"></a>4. 最大公约数</h3><p>库中__gcd(x,y)函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于求x，y的最大公约数。x,y不能是浮点数</span></span><br><span class="line"><span class="comment">//头文件：#include&lt; algorithm&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">cout&lt;&lt;__gcd(a,b)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>辗转相除法(朴素实现)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// do —— while()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        a = b;</span><br><span class="line">        b = r;</span><br><span class="line">        r = a % b;</span><br><span class="line">    &#125;<span class="keyword">while</span> (b != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> a; <span class="comment">// do--while()返回的是a</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// while()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="type">int</span> r = a % b;</span><br><span class="line">    <span class="keyword">while</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        a = b;</span><br><span class="line">        b = r;</span><br><span class="line">        r = a % b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b; <span class="comment">// do--while()返回的是a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归 + 三元运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &gt; <span class="number">0</span> ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归 + if 语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a % b == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-日期问题篇"><a href="#5-日期问题篇" class="headerlink" title="5.日期问题篇"></a>5.日期问题篇</h3><p>判断闰年</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  判断闰年</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isleap</span><span class="params">(<span class="type">int</span> year)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查日期合法性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查日期合法性</span></span><br><span class="line"><span class="type">int</span> month[<span class="number">13</span>] = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> date)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> y = date / <span class="number">10000</span>; <span class="comment">// 年</span></span><br><span class="line">    <span class="type">int</span> m = date / <span class="number">100</span> % <span class="number">100</span>; <span class="comment">// 月份</span></span><br><span class="line">    <span class="type">int</span> d = date % <span class="number">100</span>; <span class="comment">//天数</span></span><br><span class="line">    <span class="keyword">if</span> (!m || m &gt; <span class="number">12</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 月份不在1~12之间</span></span><br><span class="line">    <span class="keyword">if</span> (!day) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 天数为0</span></span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">2</span>) &#123; <span class="comment">//2月份，天数判断</span></span><br><span class="line">        <span class="keyword">if</span> (d &gt; month[<span class="number">2</span>] + <span class="built_in">isleap</span>(y)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 其他月份，天数判断</span></span><br><span class="line">        <span class="keyword">if</span> (d &gt; month[m]) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 合法</span></span><br><span class="line">&#125;        </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>构造回文日期</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出date1 ~ date2之间的 回文日期个数</span></span><br><span class="line"><span class="type">int</span> date1, date2;</span><br><span class="line">cin &gt;&gt; date1 &gt;&gt; date2;</span><br><span class="line"><span class="type">int</span> year1 = date1 / <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> year2 = date2 / <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = year1, cnt = <span class="number">0</span>; y &lt;= year2; y ++ ) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x = y, r = y; <span class="comment">// r表示构造出的回文日期</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ ) &#123;</span><br><span class="line">        r = x % <span class="number">10</span> + r * <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(r) &amp;&amp; r &gt;= date1 &amp;&amp; r &lt;= date2) &#123;</span><br><span class="line">        cnt ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-SBTree"><a href="#6-SBTree" class="headerlink" title="6.SBTree"></a>6.SBTree</h3><blockquote><p>画个图可知，在 a &#x2F; b 和 c  &#x2F; d 中夹着一个分数 a + c &#x2F; b + d;</p><p>记得判断 b + d 是否小于等于 n</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定一个整数 N,请你求出所有分母小于或等于 N,大小在 [0,1]范围内的最简分数，并按从小到大顺序依次输出。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b + d &gt; n) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">dfs</span>(a, b, a + c, b + d);</span><br><span class="line">    cout &lt;&lt; a + c &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; b + d &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">dfs</span>(a + c, b + d, c, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;0/1\n&quot;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1/1\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-完全平方数的判断"><a href="#7-完全平方数的判断" class="headerlink" title="7.完全平方数的判断"></a>7.完全平方数的判断</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> root = <span class="built_in">sqrt</span>(num);</span><br><span class="line">    <span class="keyword">if</span> (root * root == num) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-1-sqrt"><a href="#7-1-sqrt" class="headerlink" title="7.1 sqrt()"></a>7.1 sqrt()</h4><blockquote><p>返回double类型数据</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">sqrt</span><span class="params">(<span class="type">double</span> argument)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="7-2-sqrtf"><a href="#7-2-sqrtf" class="headerlink" title="7.2 sqrtf()"></a>7.2 sqrtf()</h4><blockquote><p>返回float类型的平方根</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">sqrtf</span><span class="params">(<span class="type">float</span> argument)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="7-3-sqrtl"><a href="#7-3-sqrtl" class="headerlink" title="7.3 sqrtl()"></a>7.3 sqrtl()</h4><blockquote><p>返回 long double 类型平方根</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">sqrtl</span><span class="params">(<span class="type">long</span> <span class="type">double</span> argument)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="8-分解质因数"><a href="#8-分解质因数" class="headerlink" title="8.  分解质因数"></a>8.  分解质因数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) cnt ++, x /= i;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-埃氏筛"><a href="#9-埃氏筛" class="headerlink" title="9.  埃氏筛"></a>9.  埃氏筛</h4><blockquote><p>时间复杂度: nlog(logn)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> st[N]; <span class="type">int</span> prime[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_prime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) &#123;</span><br><span class="line">            prime[cnt ++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j ++ ) st[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl; <span class="comment">// cnt : 1~n 的素数个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-欧拉筛"><a href="#10-欧拉筛" class="headerlink" title="10.  欧拉筛"></a>10.  欧拉筛</h4><blockquote><p>时间复杂度： O(n)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> st[N]; <span class="type">int</span> prime[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_prime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) prime[cnt ++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; prime[j] &lt;= n / i; j ++) &#123;</span><br><span class="line">            st[prime[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-试除法求约数"><a href="#11-试除法求约数" class="headerlink" title="11.   试除法求约数"></a>11.   试除法求约数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / i; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) v.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : v) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12"><a href="#12" class="headerlink" title="12."></a>12.</h4><img src="/lidrizzle.github.oi/D:/ChenYintaoBlogs\source\images\ImagesTypora\image-20240507233326750.png" alt="image-20240507233326750" style="zoom:67%;"><blockquote><p>未完待续….</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;lidrizzle.github.oi&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;lidrizzle</summary>
      
    
    
    
    
    <category term="NumberTheory" scheme="https://lidrizzle.github.io/lidrizzle.github.oi/tags/NumberTheory/"/>
    
  </entry>
  
  <entry>
    <title>图基础</title>
    <link href="https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/27/%E5%9B%BE%E5%9F%BA%E7%A1%80/%E5%9B%BE%E5%9F%BA%E7%A1%80/"/>
    <id>https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/27/%E5%9B%BE%E5%9F%BA%E7%A1%80/%E5%9B%BE%E5%9F%BA%E7%A1%80/</id>
    <published>2024-05-27T15:09:48.000Z</published>
    <updated>2024-05-27T15:12:01.580Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\lidrizzle.github.oi\assets\css\APlayer.min.css"><script src="\lidrizzle.github.oi\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\lidrizzle.github.oi\assets\js\Meting.min.js"></script><h1 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h1><h3 id="1-图的存储"><a href="#1-图的存储" class="headerlink" title="1. 图的存储"></a>1. 图的存储</h3><h4 id="1-1邻接表存储图"><a href="#1-1邻接表存储图" class="headerlink" title="1.1邻接表存储图"></a>1.1邻接表存储图</h4><p>时间复杂度O</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">假设我们有<span class="built_in">n</span>(n &lt;= N)个点，<span class="built_in">m</span>(m &lt;= M)条边</span><br><span class="line">我们可以想一下对于任意一个结点u, 需要记录邻边的哪些信息。</span><br><span class="line">这些信息应该包括这条邻边的终点，权重，以及下一条邻边的编号。</span><br><span class="line">注意这里不需要记录邻边的起点，因为我们使用的时候都是给出起点的。</span><br><span class="line">所以我们可以定义一个<span class="keyword">struct</span>来表示邻边:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123; </span><br><span class="line"><span class="type">int</span> eid; <span class="comment">// 该条边的编号 </span></span><br><span class="line"><span class="type">int</span> e;   <span class="comment">// 该条边的终点</span></span><br><span class="line">    <span class="type">int</span> w;   <span class="comment">// 该条边的权重</span></span><br><span class="line">    <span class="type">int</span> ne;  <span class="comment">// 下一条邻边的编号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们用上面的数据结构来记录邻边的信息，那么我们只需要定义如下变量来表示邻接表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意N和M的区别</span></span><br><span class="line"><span class="type">int</span> h[N]; <span class="comment">//下标为结点编号，h[u]：编号为u的结点第一条邻边的编号</span></span><br><span class="line">Edge edges[M];</span><br><span class="line"><span class="type">int</span> eidx;</span><br></pre></td></tr></table></figure><p>由于每条边都记录了下一条边的编号，这样我们只要把每个结点的第一条邻边的编号记录在h数组，我们就可以遍历它的每一条邻边了。</p><p>如果我们把Edge里的信息分开存到不同数组里，那么我们可以得到平时我们看到的变量定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意N和M的区别</span></span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> e[M], w[M], ne[M];  <span class="comment">// 这三个数组等价于之前的Edge edges[M]，注意这些数组的下标表示邻边的编号</span></span><br><span class="line"><span class="type">int</span> idx;  </span><br><span class="line"><span class="comment">//关键的事情说三遍：h数组的下标为结点的编号，e,w,ne数组的下标为边的编号，idx为边的编号</span></span><br></pre></td></tr></table></figure><p>把新边插入表头：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ne[idx] = h[u]; <span class="comment">//新边指向第一条邻边，即h[u];</span></span><br><span class="line">h[u] = dix ++;  <span class="comment">//更新队头的next，即新的边的编号idx;</span></span><br><span class="line"></span><br><span class="line">fouction如下：</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> weight)</span>   <span class="comment">// 添加有向边 u-&gt;v, 权重为weight</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[eidx] = v;        <span class="comment">// 记录边的终点</span></span><br><span class="line">    w[eidx] = weight;   <span class="comment">// 记录边的权重</span></span><br><span class="line">    nxt[eidx] = h[u];   <span class="comment">// 将下一条边指向结点u此时的第一条边</span></span><br><span class="line">    h[u] = eidx;        <span class="comment">// 将结点u的第一条边的编号改为此时的eidx</span></span><br><span class="line">    eidx++;             <span class="comment">// 递增边的编号edix, 为将来使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>邻接表的存储和遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M];</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (m --) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line"><span class="built_in">add</span>(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u ++ ) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> edge = h[u]; edge != <span class="number">-1</span>; edge = ne[edge]) &#123;</span><br><span class="line"><span class="type">int</span> v =   e[edge];</span><br><span class="line"><span class="type">int</span> weight = w[edge];</span><br><span class="line">cout &lt;&lt; u &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot;, wight: &quot;</span> &lt;&lt; weight &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">input:</span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line">output:</span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">4</span>, wight: <span class="number">2</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">3</span>, wight: <span class="number">3</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span>, wight: <span class="number">1</span></span><br><span class="line"><span class="number">2</span> -&gt; <span class="number">4</span>, wight: <span class="number">5</span></span><br><span class="line"><span class="number">2</span> -&gt; <span class="number">3</span>, wight: <span class="number">4</span></span><br><span class="line"><span class="number">3</span> -&gt; <span class="number">4</span>, wight: <span class="number">6</span></span><br><span class="line">input:</span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">9</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">output:</span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">3</span>, wight: <span class="number">3</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span>, wight: <span class="number">9</span></span><br><span class="line"><span class="number">2</span> -&gt; <span class="number">4</span>, wight: <span class="number">1</span></span><br><span class="line"><span class="number">3</span> -&gt; <span class="number">4</span>, wight: <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="1-2邻接矩阵存储图"><a href="#1-2邻接矩阵存储图" class="headerlink" title="1.2邻接矩阵存储图"></a>1.2邻接矩阵存储图</h4><p>时间复杂度O(n ^ 2)</p><p>存储无向图需要建立 a –&gt; b 和 b &lt;– a的两条边</p><p>邻接矩阵是表示顶点之间相邻关系的矩阵</p><blockquote><p> 第一行代表着第一个结点</p><p> 对于第一个节点所相连的结点标记为1。主对角线表示一个结点与自身相连，没有相连用无穷表示，有向图的矩阵只有在主对角线一边有路，无向图则关于主对角线对称。</p></blockquote><h3 id="2-图的遍历"><a href="#2-图的遍历" class="headerlink" title="2.图的遍历"></a>2.图的遍历</h3><p>DFS 和 BFS 的数据结构分别是<strong>栈和队列</strong></p><h4 id="2-1-DFS"><a href="#2-1-DFS" class="headerlink" title="2.1  DFS()"></a>2.1  DFS()</h4><p><strong>回溯和剪枝</strong></p><p>​<strong>回溯算法 &#x3D; 树的深度优先搜索 + <a href="https://www.zhihu.com/search?q=%E5%89%AA%E6%9E%9D%E5%87%BD%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2056261625%7D">剪枝函数</a></strong></p><blockquote><p>每个DFS都对应一个搜索树</p><p>DFS适用于所有的图，而回溯算法适用于树结构</p><p>任何解空间可以映射成树结构的问题，都可以使用回溯法。任何<a href="https://www.zhihu.com/search?q=%E8%A7%A3%E7%A9%BA%E9%97%B4&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2056261625%7D">解空间</a><strong>不能</strong>映射成树结构的问题，都<strong>不可以</strong>使用<a href="https://www.zhihu.com/search?q=%E5%9B%9E%E6%BA%AF%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2056261625%7D">回溯法</a>。</p></blockquote><p><strong>邻接表存储</strong>O(n + e) &#x2F;&#x2F;顶点 + 边</p><p>类似于树的先序遍历，对于一个<strong>连通图</strong>，深搜的步骤如下：</p><ol><li>从图中某个顶点v出发，访问v</li><li>找出刚访问过的顶点的第一个未被访问的邻接点，访问该顶点。以该顶点为新顶点，重复此步骤，直至刚访问过的顶点没有未被访问的邻接点为止。</li><li>返回前一个访问过的且仍有未被访问的邻接点的顶点，找出该顶点的下一个未被访问的邻接点，访问该顶点。</li><li>重复2、3步骤，直至图中所有顶点都被访问过，搜索结束。</li></ol><blockquote><p>搜索过程可以产生一棵<strong>深度优先生成树</strong></p><p>显然，该过程是一个递归的过程，为了在遍历过程中便于区分顶点是否已被访问，需要一个标志数组visited[n],初始为false，一旦某个顶点被访问，则其相应的分量置为true；</p></blockquote><p>深度优先遍历算法实现步骤：n</p><ol><li>从图中某个顶点出发，访问v，并置visited[v] &#x3D; true;</li><li>一次检查v的所有邻接点w，如果visited[w] &#x3D; false, 再从w出发进行递归遍历，直到所有顶点都被访问过。</li></ol><p><strong>非连通图</strong>的遍历：</p><blockquote><p>若是非连通图，上述遍历后，图中一定还有顶点未被访问，需要从图中另选一个未被访问的顶点作为起始点，重复上述深度优先搜索过程，直到图中所有顶点都被访问过为止。这样，要实现对非连通图的遍历，需要循环调用算法dfs</p></blockquote><p><strong>算法实现C++</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#Include<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], ne[N], e[N];</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"> e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">st[u] = <span class="literal">true</span>;</span><br><span class="line">cout &lt;&lt; u &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = h[u]; j != <span class="number">-1</span>; j = ne[j]) &#123;</span><br><span class="line"><span class="type">int</span> v = e[j];</span><br><span class="line"><span class="keyword">if</span> (!st[v]) &#123;</span><br><span class="line"> <span class="built_in">dfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n; <span class="comment">// n: 边的个数</span></span><br><span class="line"><span class="type">int</span> numv; <span class="comment">// numv:顶点的个数</span></span><br><span class="line">cin &gt;&gt; numv; </span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span> (n -- ) &#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="built_in">add</span>(a, b);</span><br><span class="line">        <span class="built_in">add</span>(b, a); <span class="comment">//反向加一条边，这样无论从哪个顶点遍历，都可以遍历所有的顶点</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">8</span>; i ++ ) &#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) &#123;</span><br><span class="line"><span class="built_in">dfs</span>(i); <span class="comment">// 执行一次代表一个连通块</span></span><br><span class="line">cout &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dfs(2); </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//9</span></span><br><span class="line"><span class="comment">//1 2</span></span><br><span class="line"><span class="comment">//1 3</span></span><br><span class="line"><span class="comment">//2 4</span></span><br><span class="line"><span class="comment">//2 5</span></span><br><span class="line"><span class="comment">//4 8</span></span><br><span class="line"><span class="comment">//5 8</span></span><br><span class="line"><span class="comment">//3 6</span></span><br><span class="line"><span class="comment">//3 7</span></span><br><span class="line"><span class="comment">//6 7</span></span><br><span class="line"><span class="comment">//1 -&gt; 3 -&gt; 7 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 8 -&gt; 4 -&gt;</span></span><br><span class="line"><span class="comment">//9</span></span><br><span class="line"><span class="comment">//1 3</span></span><br><span class="line"><span class="comment">//1 2</span></span><br><span class="line"><span class="comment">//2 5</span></span><br><span class="line"><span class="comment">//2 4</span></span><br><span class="line"><span class="comment">//4 8</span></span><br><span class="line"><span class="comment">//5 8</span></span><br><span class="line"><span class="comment">//3 7</span></span><br><span class="line"><span class="comment">//3 6</span></span><br><span class="line"><span class="comment">//6 7</span></span><br><span class="line"><span class="comment">//1 -&gt; 2 -&gt; 4 -&gt; 8 -&gt; 5 -&gt; 3 -&gt; 6 -&gt; 7 -&gt;</span></span><br></pre></td></tr></table></figure><p><strong>邻接矩阵存储</strong>O(n ^ 2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> g[N][N]; </span><br><span class="line"><span class="type">int</span> n;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">st[u] = <span class="literal">true</span>;</span><br><span class="line">cout &lt;&lt; u &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">8</span>; j ++ ) &#123;</span><br><span class="line"><span class="keyword">if</span> (g[u][j] == <span class="number">1</span> &amp;&amp; !st[j]) &#123;</span><br><span class="line"><span class="built_in">dfs</span>(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n; <span class="comment">// n: 边的个数 m:顶点个数 </span></span><br><span class="line"><span class="keyword">while</span> (n -- ) &#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">g[a][b] = <span class="number">1</span>; <span class="comment">// b是a的邻接点 </span></span><br><span class="line">g[b][a] = <span class="number">1</span>; <span class="comment">//反向加一条边，这样无论从哪个顶点遍历，都可以遍历所有的顶点</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//for (int i = 2; i &lt;= 8; i ++ ) &#123;</span></span><br><span class="line"><span class="comment">//if (!st[i]) &#123;</span></span><br><span class="line"><span class="comment">//dfs(i);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//9</span></span><br><span class="line"><span class="comment">//1 3</span></span><br><span class="line"><span class="comment">//1 2</span></span><br><span class="line"><span class="comment">//2 5</span></span><br><span class="line"><span class="comment">//2 4</span></span><br><span class="line"><span class="comment">//4 8</span></span><br><span class="line"><span class="comment">//5 8</span></span><br><span class="line"><span class="comment">//3 7</span></span><br><span class="line"><span class="comment">//3 6</span></span><br><span class="line"><span class="comment">//6 7</span></span><br><span class="line"><span class="comment">//1 -&gt; 2 -&gt; 4 -&gt; 8 -&gt; 5 -&gt; 3 -&gt; 6 -&gt; 7 -&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-2-BFS"><a href="#2-2-BFS" class="headerlink" title="2.2 BFS()"></a>2.2 BFS()</h4><p><strong>邻接表存储</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> h[N], ne[N], e[N];</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"> e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123; <span class="comment">// 初始从结点u开始遍历 </span></span><br><span class="line">st[u] = <span class="literal">true</span>; </span><br><span class="line">cout &lt;&lt; u &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q; <span class="comment">//创建 队列 </span></span><br><span class="line">q.<span class="built_in">push</span>(u); <span class="comment">// 将第一个顶点入队 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123; <span class="comment">//队列不为空</span></span><br><span class="line"><span class="type">int</span> t = q.<span class="built_in">front</span>(); <span class="comment">// 取队头</span></span><br><span class="line">q.<span class="built_in">pop</span>(); <span class="comment">// 删除队头</span></span><br><span class="line"><span class="comment">//遍历已取出队头的邻接点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i]) &#123;  </span><br><span class="line"><span class="type">int</span> j = e[i]; <span class="comment">// 邻接点 </span></span><br><span class="line"><span class="keyword">if</span> (!st[j]) &#123; <span class="comment">// 该邻接点没有被访问 </span></span><br><span class="line">cout &lt;&lt; j &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>; <span class="comment">//打印 </span></span><br><span class="line">st[j] = <span class="literal">true</span>; <span class="comment">// 标记该邻接点为已访问 </span></span><br><span class="line">q.<span class="built_in">push</span>(j); <span class="comment">// 入队，把该邻接点作为顶点（继续重复上述） </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n; <span class="comment">// n: 边的个数</span></span><br><span class="line"><span class="comment">//int numv; // numv:顶点的个数</span></span><br><span class="line"><span class="comment">//cin &gt;&gt; numv; </span></span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span> (n -- ) &#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="built_in">add</span>(a, b);</span><br><span class="line"><span class="built_in">add</span>(b, a);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">8</span>; i ++ ) &#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) &#123;</span><br><span class="line"><span class="built_in">bfs</span>(i);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bfs(5);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//9</span></span><br><span class="line"><span class="comment">//1 2</span></span><br><span class="line"><span class="comment">//1 3</span></span><br><span class="line"><span class="comment">//2 4</span></span><br><span class="line"><span class="comment">//2 5</span></span><br><span class="line"><span class="comment">//4 8</span></span><br><span class="line"><span class="comment">//5 8</span></span><br><span class="line"><span class="comment">//3 6</span></span><br><span class="line"><span class="comment">//3 7</span></span><br><span class="line"><span class="comment">//6 7</span></span><br></pre></td></tr></table></figure><p><strong>邻接矩阵存储</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N][N]; </span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123; <span class="comment">// 初始从结点u开始遍历 </span></span><br><span class="line">st[u] = <span class="literal">true</span>; </span><br><span class="line">cout &lt;&lt; u &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q; <span class="comment">//创建 队列 </span></span><br><span class="line">q.<span class="built_in">push</span>(u); <span class="comment">// 将第一个顶点入队 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123; <span class="comment">//队列不为空 </span></span><br><span class="line"><span class="type">int</span> t = q.<span class="built_in">front</span>(); <span class="comment">// 取队头 </span></span><br><span class="line">q.<span class="built_in">pop</span>(); <span class="comment">// 删除队头 </span></span><br><span class="line"><span class="comment">//遍历已取出队头的邻接点 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">8</span>; j ++ ) &#123;</span><br><span class="line"><span class="keyword">if</span> (!st[j] &amp;&amp; g[t][j] == <span class="number">1</span>) &#123; <span class="comment">// 该邻接点没有被访问 </span></span><br><span class="line">cout &lt;&lt; j &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>; <span class="comment">//打印 </span></span><br><span class="line">st[j] = <span class="literal">true</span>; <span class="comment">// 标记该邻接点为已访问 </span></span><br><span class="line">q.<span class="built_in">push</span>(j); <span class="comment">// 入队，把该邻接点作为顶点（继续重复上述） </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n; <span class="comment">// n: 边的个数</span></span><br><span class="line"><span class="comment">//int numv; // numv:顶点的个数</span></span><br><span class="line"><span class="comment">//cin &gt;&gt; numv; </span></span><br><span class="line"><span class="keyword">while</span> (n -- ) &#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">g[a][b] = <span class="number">1</span>;</span><br><span class="line">g[b][a] = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">8</span>; i ++ ) &#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) &#123;</span><br><span class="line"><span class="built_in">bfs</span>(i);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//bfs(7);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//9</span></span><br><span class="line"><span class="comment">//1 2</span></span><br><span class="line"><span class="comment">//1 3</span></span><br><span class="line"><span class="comment">//2 4</span></span><br><span class="line"><span class="comment">//2 5</span></span><br><span class="line"><span class="comment">//4 8</span></span><br><span class="line"><span class="comment">//5 8</span></span><br><span class="line"><span class="comment">//3 6</span></span><br><span class="line"><span class="comment">//3 7</span></span><br><span class="line"><span class="comment">//6 7</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;lidrizzle.github.oi&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;lidrizzle</summary>
      
    
    
    
    
    <category term="Graphs" scheme="https://lidrizzle.github.io/lidrizzle.github.oi/tags/Graphs/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/27/%E5%B9%B6%E6%9F%A5%E9%9B%86/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/27/%E5%B9%B6%E6%9F%A5%E9%9B%86/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2024-05-27T15:04:19.000Z</published>
    <updated>2024-05-27T15:07:50.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\lidrizzle.github.oi\assets\css\APlayer.min.css"><script src="\lidrizzle.github.oi\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\lidrizzle.github.oi\assets\js\Meting.min.js"></script><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>​        并查集作用：将两个集合合并,询问两个元素是否在一个集合当中。</p><p>数据结构类型算法,面试题容易出, 思路精巧，思维性强。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">并查集可以近乎<span class="built_in">O</span>(<span class="number">1</span>)时间复杂度之内，快速支持这两个操作</span><br><span class="line"></span><br><span class="line">基本原理：每个集合用一颗树来表示。树根的编号就是整个集合的编号。每个结点存储他的父节点。p[x]表示x的父节点。</span><br><span class="line">问题<span class="number">1</span>：如何判断树根：<span class="keyword">if</span> (p[x] == x) <span class="comment">// x的父节点是它本身</span></span><br><span class="line">问题<span class="number">2</span>：如何求x的集合编号：<span class="keyword">while</span> (p[x] != x) x = p[x]; <span class="comment">//时间消耗多，有优化，《路径压缩》，有个结点费劲千辛万苦找到了根节点，则整个路径上的所有结点都直接指向根节点，这样时间复杂度就基本是O(1)</span></span><br><span class="line">问题<span class="number">3</span>：如何合并两个集合：两棵树中，让一棵树（的根节点）插入到另一颗树的根节点下面</span><br><span class="line">    </span><br><span class="line">根节点编号是集合的编号 </span><br><span class="line">    找元素a是否在集合中s中：</span><br><span class="line">    先找到a的父节点，如果父节点是根节点，则属于的结合就是父节点的编号</span><br><span class="line">    如果父节点不是根节点，则继续向上找祖宗结点</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="并查集中一些函数"><a href="#并查集中一些函数" class="headerlink" title="并查集中一些函数"></a>并查集中一些函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不压缩</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------</span><br><span class="line"><span class="comment">//路径压缩，作用：把从x到根的路径压缩，使路径上的点指向根，使树扁平化，大大降低查询时间，时间均摊O(1);</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125; </span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="comment">//判断a, b是否连通</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">find</span>(a) == <span class="built_in">find</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并a、b各自的连通块</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">find</span>(a);</span><br><span class="line">    <span class="type">int</span> y = <span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span>; <span class="comment">// 本来就在一个连通块中</span></span><br><span class="line">    <span class="keyword">if</span> (cnt[x] &gt; cnt[y]) <span class="built_in">swap</span>(x, y); <span class="comment">//让小集合的根指向大集合</span></span><br><span class="line">        p[x] = y;</span><br><span class="line">        cnt[y] += cnt[x]; <span class="comment">// 求连通块中节点个数要用到，这里是合并后更新新的连通块中节点数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">p[i] = i;</span><br><span class="line">cnt[i] = <span class="number">1</span>; <span class="comment">//连通块中的数量问题要用到cnt[N]; ==  size[];</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>size[]：每个集合中元素数量</p><p>每个集合都是一颗树，只保证根节点的size有意义</p><p>合并两棵树，将一棵树的根节点插入到另外一颗树的根节点下面 </p><p>size[b] +&#x3D; size[a]; 更新size中的数量</p><p>如果a和b已经在同一个集合中，则continue</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;lidrizzle.github.oi&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;lidrizzle</summary>
      
    
    
    
    
    <category term="Basic Algorithms" scheme="https://lidrizzle.github.io/lidrizzle.github.oi/tags/Basic-Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>map_STL</title>
    <link href="https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/27/STL/map_STL/"/>
    <id>https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/27/STL/map_STL/</id>
    <published>2024-05-27T14:56:00.000Z</published>
    <updated>2024-05-27T14:59:59.800Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\lidrizzle.github.oi\assets\css\APlayer.min.css"><script src="\lidrizzle.github.oi\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\lidrizzle.github.oi\assets\js\Meting.min.js"></script><h1 id="《map》篇"><a href="#《map》篇" class="headerlink" title="《map》篇"></a>《map》篇</h1><p>特性：map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line">map&lt;<span class="type">int</span>&gt; mp;</span><br><span class="line">mp.<span class="built_in">find</span>(key); <span class="comment">// 返回键key的迭代器，定位key出现位置，数据存在就返回该数据位置迭代器，反之，返回mp.end();</span></span><br><span class="line">mp.<span class="built_in">erase</span>(key); <span class="comment">//根据键删除键值对0(logN)</span></span><br><span class="line">mp.<span class="built_in">erase</span>(it);  <span class="comment">//根据迭代器删除键和值0(1)</span></span><br><span class="line">mp.<span class="built_in">erase</span>(first, last); <span class="comment">// 删除左闭右开迭代器对应的键值</span></span><br><span class="line">mp.<span class="built_in">size</span>(); <span class="comment">// 返回映射对数</span></span><br><span class="line">mp.<span class="built_in">clear</span>(); <span class="comment">//清空map中所有元素</span></span><br><span class="line">mp.<span class="built_in">insert</span>();<span class="comment">//插入元素，插入时要构造键值对</span></span><br><span class="line">mp.<span class="built_in">empty</span>();<span class="comment">//如果map为空，返回true，否则返回false</span></span><br><span class="line">mp.<span class="built_in">begin</span>();<span class="comment">//返回第一个元素的迭代器</span></span><br><span class="line">mp.<span class="built_in">end</span>(); <span class="comment">//返回最后一个元素的下一个迭代器</span></span><br><span class="line">mp.<span class="built_in">rbegin</span>(); <span class="comment">//返回指向map的最有一个迭代器</span></span><br><span class="line">mp.<span class="built_in">rend</span>();<span class="comment">//返回指向map的第一个元素前面一个位置迭代器</span></span><br><span class="line">mp.<span class="built_in">count</span>(key);<span class="comment">//查看元素是否存在，因为map中键是唯一的，存在为true，反之false</span></span><br><span class="line">mp.<span class="built_in">lower_bound</span>();<span class="comment">//返回一个迭代器，指向键值 &gt;= key的第一个元素</span></span><br><span class="line">mp.<span class="built_in">upper_bound</span>();<span class="comment">//指向键值 &gt; key 的第一个元素</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;lidrizzle.github.oi&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;lidrizzle</summary>
      
    
    
    
    
    <category term="STL" scheme="https://lidrizzle.github.io/lidrizzle.github.oi/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>queue_STL</title>
    <link href="https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/27/STL/queue_STL/"/>
    <id>https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/27/STL/queue_STL/</id>
    <published>2024-05-27T14:54:19.000Z</published>
    <updated>2024-05-27T15:00:08.487Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\lidrizzle.github.oi\assets\css\APlayer.min.css"><script src="\lidrizzle.github.oi\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\lidrizzle.github.oi\assets\js\Meting.min.js"></script><h1 id="《queue》篇"><a href="#《queue》篇" class="headerlink" title="《queue》篇"></a>《queue》篇</h1><p>头文件queue主要包括循环队列queue 和 优先队列 priority_queue两个容器。</p><blockquote><p>#include <queue> </queue></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">res</span>&#123;...&#125;; queue&lt;rec&gt; q; <span class="comment">//结构体rec中必须定义小于号</span></span><br></pre></td></tr></table></figure><h3 id="1-循环队列"><a href="#1-循环队列" class="headerlink" title="1.循环队列"></a>1.循环队列<queue></queue></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push</span>(); <span class="comment">// 从队尾插入</span></span><br><span class="line"><span class="built_in">pop</span>();  <span class="comment">// 从队头弹出</span></span><br><span class="line"><span class="built_in">front</span>();<span class="comment">// 返回队头元素</span></span><br><span class="line"><span class="built_in">back</span>(); <span class="comment">// 返回队尾元素</span></span><br></pre></td></tr></table></figure><h3 id="2-数组模拟队列"><a href="#2-数组模拟队列" class="headerlink" title="2.  数组模拟队列"></a>2.  数组模拟队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">用一个数组 q 保存数据。</span><br><span class="line"></span><br><span class="line">用 hh 代表队头，q[hh] 就是队头元素， q[hh + <span class="number">1</span>] 就是第二个元素。</span><br><span class="line"></span><br><span class="line">用 tt 代表队尾， q[tt] 就是队尾元素， q[tt + <span class="number">1</span>] 就是下一次入队，元素应该放的位置。</span><br><span class="line"></span><br><span class="line">[hh, tt] 左闭右闭，代表队列中元素所在的区间。</span><br><span class="line"></span><br><span class="line">出队pop：因为 hh 代表队头，[hh, tt] 代表元素所在区间。所以出队可以用 hh++实现，hh++后，区间变为[hh + <span class="number">1</span>, tt]。</span><br><span class="line"></span><br><span class="line">入队push：因为 tt 代表队尾，[hh, tt] 代表元素所在区间。所以入出队可以用 tt++实现，tt++后，区间变为[hh, tt + <span class="number">1</span>], 然后在q[tt+<span class="number">1</span>]位置放入入队元素。</span><br><span class="line"></span><br><span class="line">是否为空empty：[hh, tt] 代表元素所在区间，当区间非空的时候，对列非空。也就是tt &gt;= hh的时候，对列非空。</span><br><span class="line"></span><br><span class="line">询问队头query：用 hh 代表队头，q[hh] 就是队头元素，返回 q[hh] 即可。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//[hh, tt] 之间为队列（左闭右闭）</span></span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>;<span class="comment">//队头位置</span></span><br><span class="line"><span class="type">int</span> tt = <span class="number">-1</span>;<span class="comment">//队尾位置</span></span><br><span class="line"><span class="comment">//操作次数</span></span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="comment">//操作方式</span></span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队：队尾先往后移动一格，再放入要插入的数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    q[++tt] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队：队头往后移动一格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    hh++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[hh, tt]表示队列区间，当tt &gt;= hh时，区间不为空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tt &gt;= hh) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//hh指向队头，q[hh]代表队头元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; q[hh] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="comment">//入队</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;push&quot;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出队</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;pop&quot;</span>)&#123;</span><br><span class="line">            <span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//问空</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;empty&quot;</span>)&#123;</span><br><span class="line">            <span class="built_in">empty</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//问队头</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;query&quot;</span>)&#123;</span><br><span class="line">            <span class="built_in">query</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-优先队列"><a href="#3-优先队列" class="headerlink" title="3.  优先队列"></a>3.  优先队列<priority_queue></priority_queue></h3><p>堆的内部是二叉平衡树</p><blockquote><p>​priority_queue是一种能根据元素优先级进行一系列操作的队列。他和queue不同的就在于我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队</p><p>​优先队列具有队列的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型</span></span><br><span class="line">priority_queue&lt;Type, Container, Functional&gt;;</span><br><span class="line"><span class="comment">//其中, Type 为数据类型. Container 为保存数据的容器. Functional 为元素比较的方式.</span></span><br><span class="line"><span class="comment">//若不写后面两个参数.容器 默认使用 vector</span></span><br><span class="line"><span class="comment">//比较方式 默认使用 operator &lt; 即优先队列是大顶堆. 队头元素最大</span></span><br></pre></td></tr></table></figure><h4 id="2-1声明a"><a href="#2-1声明a" class="headerlink" title="2.1声明a"></a>2.1声明a</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;  <span class="comment">//大根堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q; <span class="comment">//升序排列, 小根堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt;q;     <span class="comment">//降序队列， 大根堆</span></span><br></pre></td></tr></table></figure><h4 id="2-2操作"><a href="#2-2操作" class="headerlink" title="2.2操作"></a>2.2操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入函数</span></span><br><span class="line">q.<span class="built_in">push</span>(k):<span class="comment">//在q的末尾插入k,并排序</span></span><br><span class="line">q.<span class="built_in">emplace</span>(); <span class="comment">//原地构造一个元素并插入队列</span></span><br><span class="line"><span class="comment">//删除函数</span></span><br><span class="line">q.<span class="built_in">pop</span>():<span class="comment">//删除q的第一个元素</span></span><br><span class="line"><span class="comment">//判空函数</span></span><br><span class="line">q.<span class="built_in">empty</span>():<span class="comment">//返回q是否为空，空则返回true</span></span><br><span class="line"><span class="comment">//大小函数</span></span><br><span class="line">q.<span class="built_in">size</span>():<span class="comment">//返回q里元素个数</span></span><br><span class="line"><span class="comment">// 其他</span></span><br><span class="line">q.<span class="built_in">top</span>():<span class="comment">//查询q的第一个元素     //注意：首元素是top();不是front();</span></span><br><span class="line"><span class="built_in">swap</span>();<span class="comment">// 交换内容</span></span><br></pre></td></tr></table></figure><h3 id="4-自定义比较函数"><a href="#4-自定义比较函数" class="headerlink" title="4.  自定义比较函数"></a>4.  自定义比较函数</h3><p>自定义就不能用greater<int>或者less<int>啦，需要自定义比较方式</int></int></p><p>附上链接：<a href="https://www.acwing.com/file_system/file/content/whole/index/content/6311328/">https://www.acwing.com/file_system/file/content/whole/index/content/6311328/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node&amp; b) <span class="type">const</span> &#123; <span class="comment">//定义在内部，重载 &lt; 号，最后的const要写上</span></span><br><span class="line"><span class="keyword">if</span> (l == b.l) <span class="keyword">return</span> r &lt;= b.r;</span><br><span class="line"><span class="keyword">return</span> l &lt; b.l; <span class="comment">// 从小到大排序，大根堆</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node, vector&lt;node&gt; k;</span><br><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line"><span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">k.<span class="built_in">push</span>(&#123;l, r&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (k.<span class="built_in">size</span>()) &#123;</span><br><span class="line">cout &lt;&lt; k.<span class="built_in">top</span>().l &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; k.<span class="built_in">top</span>().r &lt;&lt; endl;</span><br><span class="line">k.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="number">4</span></span><br><span class="line"><span class="comment">// 1 5</span></span><br><span class="line"><span class="comment">// 2 3</span></span><br><span class="line"><span class="comment">// 5 6</span></span><br><span class="line"><span class="comment">// 3 2</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123; <span class="comment">//定义在外部，此时重载()符号</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> Node&amp; a, <span class="type">const</span> Node&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.l &gt; b.l;<span class="comment">//将l的值由小到大排列，形成Node的小根堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;lidrizzle.github.oi&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;lidrizzle</summary>
      
    
    
    
    
    <category term="STL" scheme="https://lidrizzle.github.io/lidrizzle.github.oi/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>sort_STL</title>
    <link href="https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/26/STL/sort_STL/"/>
    <id>https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/26/STL/sort_STL/</id>
    <published>2024-05-26T03:26:03.000Z</published>
    <updated>2024-05-26T08:57:09.325Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\lidrizzle.github.oi\assets\css\APlayer.min.css"><script src="\lidrizzle.github.oi\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\lidrizzle.github.oi\assets\js\Meting.min.js"></script><h1 id="《排序》篇"><a href="#《排序》篇" class="headerlink" title="《排序》篇"></a>《排序》篇</h1><h3 id="1-sort"><a href="#1-sort" class="headerlink" title="1.sort()"></a>1.sort()</h3><blockquote><p>时间复杂度：nlog(n)</p><p>它对普通的快速排序进行了优化，此外，它还结合了插入排序和推排序。系统会根据你的数据形式和数据量自动选择合适的排序方法，这并不是说它每次排序只选择一种方法，它是在一次完整排序中不同的情况选用不同方法，比如给一个数据量较大的数组排序，开始采用快速排序，分段递归，分段之后每一段的数据量达到一个较小值后它就不继续往下递归，而是选择插入排序，如果递归的太深，他会选择推排序。<br>————————————————</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(first_pointer, first_pointer + n, cmp); <span class="comment">// n:数组长度</span></span><br><span class="line">参数解释： 第一个参数是数组的首地址，一般写上数组名就可以，因为数组名是一个指针常量。第二个参数相对较好理解，即首地址加上数组的长度n（代表尾地址的下一地址）。最后一个参数是比较函数的名称（自定义函数cmp），这个比较函数可以不写，即第三个参数可以缺省，这样sort会默认按数组升序排序。</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">形式:</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(a,<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">// 默认升序排列</span></span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), cmp); <span class="comment">//  根据cmp决定</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sort</span>(a, a + n);</span><br><span class="line">对数组A的<span class="number">0</span>~n<span class="number">-1</span>元素进行升序排序，只要写<span class="built_in">sort</span>(a, a + n);即可；对于向量V也一样，<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>())即可。</span><br></pre></td></tr></table></figure><p>定义比较函数cmp()：(最常用)</p><ol><li>使用标准库函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a, a + n, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 降序排列</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n, <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());    <span class="comment">// 升序排列（默认）</span></span><br></pre></td></tr></table></figure><ol start="2"><li>重载结构体或类的比较运算符</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一：在结构体内部重载</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">double</span> grade;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> student&amp; s) &#123;</span><br><span class="line">        <span class="keyword">return</span> id &gt; s.id; <span class="comment">// 降序排列</span></span><br><span class="line">        <span class="keyword">return</span> id &lt; s.id; <span class="comment">// 升序排列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;student&gt; v;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">//  ！！！要加上sort()才可以排序使用bool operator &lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二：在外部重载</span></span><br><span class="line"></span><br><span class="line">vector&lt;student&gt; v;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> student&amp; s1, <span class="type">const</span> student&amp; s2) &#123;</span><br><span class="line">    <span class="keyword">return</span> s1.id &gt; s2.id; <span class="comment">//降序排列</span></span><br><span class="line">    <span class="keyword">return</span> s1.id &lt; s2.id; <span class="comment">//升序排列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h3 id="2-lambda表达式"><a href="#2-lambda表达式" class="headerlink" title="2.  lambda表达式"></a>2.  lambda表达式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [&amp;](PII &amp;a, PII &amp;b) &#123;<span class="keyword">return</span> a.y &lt; b.y;&#125;);</span><br></pre></td></tr></table></figure><img src="/lidrizzle.github.oi/D:/ChenYintaoBlogs\source\images\ImagesTypora\lambda.png">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;lidrizzle.github.oi&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;lidrizzle</summary>
      
    
    
    
    
    <category term="STL" scheme="https://lidrizzle.github.io/lidrizzle.github.oi/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>set_STL</title>
    <link href="https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/26/STL/set_STL/"/>
    <id>https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/26/STL/set_STL/</id>
    <published>2024-05-26T03:22:37.000Z</published>
    <updated>2024-05-26T06:45:53.144Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\lidrizzle.github.oi\assets\css\APlayer.min.css"><script src="\lidrizzle.github.oi\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\lidrizzle.github.oi\assets\js\Meting.min.js"></script><h1 id="《set集合》篇"><a href="#《set集合》篇" class="headerlink" title="《set集合》篇"></a>《set集合》篇</h1><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><blockquote><p> C++标准模板库（STL）中的<code>set</code>是一个容器类，它实现了有序、唯一元素的集合。</p></blockquote><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h3><ul><li>唯一性：<code>set</code>中的元素是<strong>唯一</strong>的，即每个元素<strong>只能出现一次。</strong></li><li>自动排序：<code>set</code>中的元素按升序排序，默认使用 <code>&lt;</code> 运算符进行比较。您也可以自定义比较函数来指定排序规则。<ul><li>动态大小： <code>set</code>可以根据需要动态调整大小，可以插入或删除元素。</li></ul></li></ul><h3 id="3-头文件"><a href="#3-头文件" class="headerlink" title="3.头文件"></a>3.头文件</h3><blockquote><p><code>set</code>位于 <code>&lt;set&gt;</code> 头文件中，您需要包含这个头文件才能使用<code>set</code>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="4-常用操作"><a href="#4-常用操作" class="headerlink" title="4.常用操作"></a>4.常用操作</h3><ul><li>插入元素：使用 <code>insert()</code> 成员函数将元素插入<code>set</code>中。<code>emplace()</code>比<code>insert()</code>更加高效</li><li>删除元素：使用 <code>erase()</code> 成员函数删除指定元素或范围内的元素。</li><li>查找元素：使用 <code>find()</code> 成员函数查找指定元素，如果找到则返回元素的迭代器，否则返回<code>set</code>结尾的迭代器。</li><li>访问元素：<code>set</code>中的元素是只读的，您可以使用迭代器来访问元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mySet.<span class="built_in">begin</span>(); it != mySet.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = mySet.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element found: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    mySet.<span class="built_in">erase</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出结果:</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">8</span></span><br><span class="line">Element found: <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="5-拓展"><a href="#5-拓展" class="headerlink" title="5.拓展"></a>5.拓展</h3><ol><li><h6 id="元素比较和排序："><a href="#元素比较和排序：" class="headerlink" title="元素比较和排序："></a>元素比较和排序：</h6><ul><li>默认情况下，<code>set</code>使用 <code>&lt;</code> 运算符进行比较元素。这意味着元素类型必须支持 <code>&lt;</code> 运算符，或者您可以提供自定义的比较函数。</li><li>如果您想使用自定义的比较函数，可以在创建<code>set</code>对象时提供该函数或通过模板参数指定。</li><li>自定义比较函数应采用两个参数，并返回一个布尔值，表示第一个参数是否小于第二个参数。</li></ul></li><li><h6 id="set的底层实现："><a href="#set的底层实现：" class="headerlink" title="set的底层实现："></a><code>set</code>的底层实现：</h6><ul><li><code>set</code>通常使用红黑树（Red-Black Tree）作为其底层实现。红黑树是一种自平衡二叉搜索树，它保持树的高度较小，从而提供高效的插入、删除和查找操作。</li><li>由于红黑树的特性，<code>set</code>中的元素总是按照升序排列。</li></ul></li><li><h6 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h6><ul><li>插入、删除和查找操作的平均时间复杂度是 O(log n)，其中 n 是<code>set</code>中的元素数量。</li></ul></li><li><h6 id="multiset："><a href="#multiset：" class="headerlink" title="multiset："></a><code>multiset</code>：</h6><ul><li><code>multiset</code>是<code>set</code>的变体，允许存储重复的元素。与<code>set</code>不同，<code>multiset</code>中的元素不会被唯一化。</li><li><code>multiset</code>提供了与<code>set</code>相同的接口和操作，并且具有类似的性能特征。</li></ul></li><li><h6 id="使用自定义类型："><a href="#使用自定义类型：" class="headerlink" title="使用自定义类型："></a>使用自定义类型：</h6><ul><li>您可以在<code>set</code>中存储自定义类型的元素。为了使<code>set</code>正常工作，您需要定义元素类型的 <code>&lt;</code> 运算符或自定义比较函数。</li><li>默认情况下，<code>set</code>使用元素类型的 <code>&lt;</code> 运算符进行比较。如果元素类型不支持 <code>&lt;</code> 运算符，您需要提供自定义的比较函数。</li></ul></li><li><h6 id="其他成员函数和操作："><a href="#其他成员函数和操作：" class="headerlink" title="其他成员函数和操作："></a>其他成员函数和操作：</h6><ul><li><code>set</code>还提供了其他一些有用的成员函数和操作，如<code>size()</code>（返回<code>set</code>中元素的数量）、<code>empty()</code>（检查<code>set</code>是否为空）等。</li><li>您可以使用范围构造函数、范围插入函数、交集、并集、差集等操作来处理<code>set</code>对象。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;lidrizzle.github.oi&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;lidrizzle</summary>
      
    
    
    
    
    <category term="STL" scheme="https://lidrizzle.github.io/lidrizzle.github.oi/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>cstring_STL</title>
    <link href="https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/26/STL/cstring_STL/"/>
    <id>https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/26/STL/cstring_STL/</id>
    <published>2024-05-26T03:21:26.000Z</published>
    <updated>2024-05-26T06:45:41.937Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\lidrizzle.github.oi\assets\css\APlayer.min.css"><script src="\lidrizzle.github.oi\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\lidrizzle.github.oi\assets\js\Meting.min.js"></script><h1 id="《cstring》篇"><a href="#《cstring》篇" class="headerlink" title="《cstring》篇"></a>《cstring》篇</h1><h2 id="1-操作函数"><a href="#1-操作函数" class="headerlink" title="1.操作函数"></a>1.操作函数</h2><h3 id="1-substr-pos-len"><a href="#1-substr-pos-len" class="headerlink" title="1.  substr(pos, len)"></a>1.  substr(pos, len)</h3><blockquote><p>返回值：string，从pos开始的len个字符的拷贝</p><p>pos：默认0</p><p>len：默认s.size() - 1, 也就是到最后了</p></blockquote><p>如果最后取不到len长度的字符串，则只取剩余的所有字串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    string a = <span class="string">&quot;ac&quot;</span>;</span><br><span class="line">    a += <span class="string">&quot;w&quot;</span>;<span class="comment">//支持比较操作符&gt;,&gt;=,&lt;,&lt;=,==,!=</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl; <span class="comment">//输出子串a :acw</span></span><br><span class="line"></span><br><span class="line">    a += <span class="string">&quot;ing&quot;</span>;  </span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//以字符串数组理解</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">3</span>) &lt;&lt; endl; <span class="comment">//当第一个数是0 则后一位数:输出从头开始的长度为3的子串</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">3</span>) &lt;&lt; endl; <span class="comment">//当第一个数是1 则输出下标为1 到下标为3的子串  </span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">9</span>) &lt;&lt; endl;<span class="comment">//如果超出长度范围 则输出原子串</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">1</span>) &lt;&lt; endl; <span class="comment">//从下标为1开始输出</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">substr</span>(<span class="number">0</span>) &lt;&lt; endl; <span class="comment">//原子串</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a.<span class="built_in">c_str</span>());<span class="comment">//如果用printf输出  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="2-transform-first-last-result-op"><a href="#2-transform-first-last-result-op" class="headerlink" title="2.  transform(first, last, result, op);"></a>2.  transform(first, last, result, op);</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">作用：将某操作应用于指定范围的每个元素。</span><br><span class="line"></span><br><span class="line">first：容器首迭代器ffffflast：容器末迭代器sssssssssssfffffffffFDff</span><br><span class="line"></span><br><span class="line">op：操作的一元 n</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">first1：第一个容器首迭代器</span><br><span class="line"></span><br><span class="line">last1：末迭代器</span><br><span class="line"></span><br><span class="line">first2： 第二个容器的首迭代器</span><br><span class="line"></span><br><span class="line">result：存放结果的容器</span><br><span class="line"></span><br><span class="line">binary_op：要进行操作的二元函数对象</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将字符串小写字母改大写，将结果保存在second数组中</span></span><br><span class="line"><span class="built_in">transform</span>(first1.<span class="built_in">begin</span>(), first1.<span class="built_in">end</span>(), first2.<span class="built_in">begin</span>(), ::tolower);</span><br></pre></td></tr></table></figure><h3 id="3-find-a-b-c-d"><a href="#3-find-a-b-c-d" class="headerlink" title="3. find(a, b,  c, d)"></a>3. find(a, b,  c, d)</h3><blockquote><p> s.rfind(str)： 是从字符串右侧开始匹配str，并返回在字符串中的下标位置；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(string s)</span> </span>&#123; <span class="comment">//在母串s中找字串subs的个数</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">string subs = <span class="string">&quot;chuanzhi&quot;</span>;</span><br><span class="line"><span class="type">int</span> ind = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> len = subs.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span> (s.<span class="built_in">find</span>(subs, ind) != <span class="number">-1</span>) &#123; <span class="comment">// string::npos</span></span><br><span class="line">cnt ++;</span><br><span class="line">ind = s.<span class="built_in">find</span>(subs, ind) + len;<span class="comment">// 核心</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//string中find()返回值是字母在母串中的下标位置。</span></span><br><span class="line"><span class="comment">//s.find（str，pos）</span></span><br><span class="line"><span class="comment">//find(str,pos)是用来寻找从pos开始(包括pos处字符)匹配str的位置</span></span><br><span class="line"><span class="comment">//如果没有找到，那么会返回一个特别的标记npos，一般写作string::npos。</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>find_first_of()函数</strong></p><p><strong>正向查找在原字符串中第一个与指定字符串（或字符）中的某个字符匹配的字符</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_first_of</span>(<span class="type">char</span>);一般是用来找单个字符，参数也可以是字符串类型；</span><br><span class="line"></span><br><span class="line">如：subs = <span class="string">&quot;chuanzhi&quot;</span>; s = <span class="string">&quot;welcometochangzhi&quot;</span>;</span><br><span class="line">则:s.<span class="built_in">find_first_of</span>(subs)，如果是字符串，则找的是，s中最先出现subs中字符的位置</span><br></pre></td></tr></table></figure><h3 id="4-insert"><a href="#4-insert" class="headerlink" title="4. insert()"></a>4. insert()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾插一个字符</span></span><br><span class="line">    a.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">// insert(pos,char):在制定的位置pos前插入字符char</span></span><br><span class="line">    a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>(),<span class="string">&#x27;1&#x27;</span>); <span class="comment">//输出 1a</span></span><br><span class="line">  <span class="comment">//插入字符串</span></span><br><span class="line">  string str2=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    string s2=<span class="string">&quot;weakhaha&quot;</span>;</span><br><span class="line">    str2.<span class="built_in">insert</span>(<span class="number">0</span>,s2,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//将字符串s2从下标为1的e开始数3个字符，分别是eak，插入原串的下标为0的字符h前    </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="5-c-str"><a href="#5-c-str" class="headerlink" title="5.c_str()"></a>5.c_str()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回这个string对应的字符数组的头指针</span></span><br><span class="line">string s = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s.<span class="built_in">c_str</span>()); <span class="comment">//输出 &quot;Hello World!&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-接收字符串方法"><a href="#2-接收字符串方法" class="headerlink" title="2.接收字符串方法"></a>2.接收字符串方法</h2><h3 id="2-1-cin-str-字符串"><a href="#2-1-cin-str-字符串" class="headerlink" title="2.1  cin(str)字符串"></a>2.1  cin(str)字符串</h3><blockquote><p>作用：可接受单词字符，串遇空格停止</p></blockquote><h3 id="2-2-getline-cin-str"><a href="#2-2-getline-cin-str" class="headerlink" title="2.2  getline(cin, str)"></a>2.2  getline(cin, str)</h3><blockquote><p>作用：接受一行字符串，丢弃最后一个换行符</p></blockquote><h3 id="2-3-fgets-str-max-stdin"><a href="#2-3-fgets-str-max-stdin" class="headerlink" title="2.3  fgets(str, max, stdin)"></a>2.3  fgets(str, max, stdin)</h3><blockquote><p>作用：接收一行字符串</p><p>前提：char str[max]</p></blockquote><h3 id="2-4-cin-ignore-a-b"><a href="#2-4-cin-ignore-a-b" class="headerlink" title="2.4  cin.ignore(a, b)"></a>2.4  cin.ignore(a, b)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">ignore</span>() 函数是C++标准输入流（cin）中的一个方法。cin.<span class="built_in">ignore</span>()函数中有两个参数，分别为数值型的a 和 字符型的 ch ，即cin.<span class="built_in">ignore</span>( a, ch )。它表示从输入流 cin 中提取字符，提取的字符被忽略，不被使用。而每抛弃一个字符，它都要进行计数和比较字符：如果计数值达到 a 或者被抛弃的字符是 ch ，则cin.<span class="built_in">ignore</span>() 函数执行终止；否则，它继续等待。</span><br><span class="line">    它的一个常用功能就是用来清除以回车结束的输入缓冲区的内容，消除上一次输入对下一次输入的影响。例如可以这么用，cin.<span class="built_in">ignore</span>(<span class="number">1024</span>, <span class="string">&#x27;\n&#x27;</span>)，通常把第一个参数设置得足够大，这样实际上是为了只有第二个参数 <span class="string">&#x27;\n&#x27;</span> 起作用，所以这一句就是把回车（包括回车）之前的所以字符从输入缓冲流中清除出去。</span><br><span class="line"></span><br><span class="line">如果默认不给参数的话，默认参数为cin.<span class="built_in">ignore</span>(<span class="number">1</span>, EOF)，即把EOF前的<span class="number">1</span>个字符清掉,没有遇到EOF就清掉一个字符然后\结束。</span><br></pre></td></tr></table></figure><h3 id="3-memset-a-0x3f-sizeof-a-0"><a href="#3-memset-a-0x3f-sizeof-a-0" class="headerlink" title="3.  memset(a, 0x3f, sizeof(a[0]))"></a>3.  memset(a, 0x3f, sizeof(a[0]))</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(arrayName, <span class="type">int</span> c, <span class="built_in">sizeoif</span>(arrayName[<span class="number">0</span>]));</span><br><span class="line">数组中每个元素不能初始化为<span class="number">1</span></span><br><span class="line">因为：一个字节一个字节的设置，把一个<span class="type">int</span>的每个字节都设置为<span class="number">1</span>，也就是<span class="number">0x01010101</span>,十进制就是<span class="number">16843009</span></span><br><span class="line">二进制就是：<span class="number">00000001</span> <span class="number">00000001</span> <span class="number">00000001</span> <span class="number">00000001</span></span><br><span class="line"><span class="number">2</span> ^ <span class="number">24</span> + <span class="number">2</span> ^ <span class="number">16</span> + <span class="number">2</span> ^ <span class="number">8</span> + <span class="number">2</span> ^ <span class="number">0</span> = <span class="number">16843009</span></span><br><span class="line"></span><br><span class="line">可以初始化为 ：<span class="number">0</span> 、<span class="number">-1</span>、<span class="number">0x3f</span>(无穷大) </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;lidrizzle.github.oi&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;lidrizzle</summary>
      
    
    
    
    
    <category term="STL" scheme="https://lidrizzle.github.io/lidrizzle.github.oi/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>vector_STL</title>
    <link href="https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/24/STL/vector_STL/"/>
    <id>https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/24/STL/vector_STL/</id>
    <published>2024-05-24T06:06:59.000Z</published>
    <updated>2024-05-26T06:46:17.430Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\lidrizzle.github.oi\assets\css\APlayer.min.css"><script src="\lidrizzle.github.oi\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\lidrizzle.github.oi\assets\js\Meting.min.js"></script><h1 id="《vector》篇"><a href="#《vector》篇" class="headerlink" title="《vector》篇"></a>《vector》篇</h1><p>vector中的容量变化为：增长策略对不同编译器或库是不同的。</p><h3 id="1-元素去重的三个方法"><a href="#1-元素去重的三个方法" class="headerlink" title="1.  元素去重的三个方法"></a>1.  元素去重的三个方法</h3><p>(1)结合sort和unique函数</p><blockquote><p>unique()函数将相邻且重复的元素放到<a href="https://so.csdn.net/so/search?q=vector&spm=1001.2101.3001.7020">vector</a>的尾部 然后返回指向第一个重复元素的迭代器再用erase函数擦除从这个元素到最后元素的所有的元素。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">vec.<span class="built_in">erase</span>(<span class="built_in">unique</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()), vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>(2)简单的利用set的特性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="type">int</span> myints[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(myints)/<span class="built_in">sizeof</span>(<span class="type">int</span>); <span class="comment">//求静态数组长度</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(myints, myints + len)</span></span>;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;<span class="built_in">s</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">vec.<span class="built_in">assign</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>(3)使用remove()函数，删除容器中和指定元素值相同的所有元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>删除容器中所有和指定元素值相等的元素，并返回指向最后一个元素下一个位置的迭代器。值得一提的是，调用该函数不会改变容器的大小和容量。</p></blockquote><h3 id="2-cmp-排序"><a href="#2-cmp-排序" class="headerlink" title="2.  cmp()排序"></a>2.  cmp()排序</h3><p>使用sort()给vector&lt;pair&lt;int, int&gt;&gt; 排序，sort默认是按照pair的first升序排序，如果first相同，则按照second进行升序排序，具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.first == b.first) <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">    <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-unique"><a href="#3-unique" class="headerlink" title="3.  unique()"></a>3.  unique()</h3><p>从头到尾，判断当前元素是否等于上一个元素，**将不重复的元素移到前面来(赋值操作)**，而不是将重复的元素移动到后面去。</p><p>因为是判断当前元素是否等于上一个元素，所以要去重的容器必须是经过排序的有序容器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unique讲解示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//1 2 3 3 4 5 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//pos是去重以后vector中没有重复元素的下一个位置的迭代器</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator pos = <span class="built_in">unique</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> index = pos - v.<span class="built_in">begin</span>(); <span class="comment">// 没有重复元素的下一个位置的坐标</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//去重后整个容器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; v[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//1 2 3 4 5 5 5</span></span><br><span class="line"><span class="comment">//从容器开始到pos：去重后的容器元素</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator i = v.<span class="built_in">begin</span>(); i &lt; pos; i++) &#123;</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从pos到容器结束：无意义的元素</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator i = pos; i &lt; v.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//5 5</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-erase"><a href="#4-erase" class="headerlink" title="4.  erase()"></a>4.  erase()</h3><p>可以删除指定位置的元素，或指定范围的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型如下：</span></span><br><span class="line">（<span class="number">1</span>）<span class="function">string&amp; <span class="title">erase</span> <span class="params">( <span class="type">size_t</span> pos = <span class="number">0</span>, <span class="type">size_t</span> n = npos )</span></span>;</span><br><span class="line">（<span class="number">2</span>）<span class="function">iterator <span class="title">erase</span> <span class="params">( iterator position )</span></span>;</span><br><span class="line">（<span class="number">3</span>）<span class="function">iterator <span class="title">erase</span> <span class="params">( iterator first, iterator last )</span></span>;</span><br><span class="line"><span class="comment">//也就是说有三种用法</span></span><br><span class="line">（<span class="number">1</span>）<span class="built_in">erase</span>(pos,n); 删除从pos开始的n个字符，比如<span class="built_in">erase</span>(<span class="number">0</span>,<span class="number">1</span>)就是删除第一个字符</span><br><span class="line">（<span class="number">2</span>）<span class="built_in">erase</span>(position);删除position处的一个字符(position是个string类型的迭代器)</span><br><span class="line">（<span class="number">3</span>）<span class="built_in">erase</span>(first,last);删除从first到last之间的字符（first和last都是迭代器）</span><br></pre></td></tr></table></figure><p>erase函数的返回值是这么介绍的：<strong>一个迭代器，指定在任何删除的元素之后剩余的第一个元素，如果不存在这样的元素，则指定指向向量结尾的指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vector去重无序数组且要保持原来的顺序</span></span><br><span class="line"><span class="comment">//比如：</span></span><br><span class="line"><span class="comment">//1，3，1，7，5，7</span></span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line"><span class="comment">//1，3，7，5</span></span><br><span class="line"><span class="comment">//原理：就是简单比较当前元素是否出现在当前元素之前的数组中，如果没有才填入。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_readingOrder</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vec)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecprint;</span><br><span class="line"><span class="comment">//第一个元素不用比</span></span><br><span class="line">vecprint.<span class="built_in">push_back</span>(vec[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;vec.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line"><span class="type">bool</span> tag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j =<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vec[i]==vec[j]) &#123;</span><br><span class="line">tag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tag==<span class="literal">true</span>)vecprint.<span class="built_in">push_back</span>(vec[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制台输出</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vecprint.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">cout&lt;&lt;vecprint[i]&lt;&lt;endl;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-min-max-element"><a href="#5-min-max-element" class="headerlink" title="5.  min&#x2F;max_element()"></a>5.  min&#x2F;max_element()</h3><p>求vector容器中的最小&#x2F;最大元素。</p><blockquote><p> 接收参数：容器的首尾地址（迭代器）（可以是一个区间）</p><p> 返回：最值元素的<strong>地址</strong>（迭代器），需要减去序列头以转换为下标</p><p> *<strong>max_element（）与*min_element（）</strong>分别用来求最大元素和最小元素的值。</p><p> 返回的是迭代器</p><p> cout &lt;&lt; v[  max_element(  v.begin(),  v.end() )  -  v.begin() ];</p></blockquote><h3 id="6-vector的遍历"><a href="#6-vector的遍历" class="headerlink" title="6.  vector的遍历"></a>6.  vector的遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it ++ ) &#123;</span><br><span class="line">    cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种使用auto</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it ++ ) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种 定义反向迭代器</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;reverse_iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = v.<span class="built_in">rbegin</span>(); it != v.<span class="built_in">rend</span>(); it ++ ) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第四种 使用auto同第二种</span></span><br></pre></td></tr></table></figure><h3 id="7-vector的创建和初始化"><a href="#7-vector的创建和初始化" class="headerlink" title="7.   vector的创建和初始化"></a>7.   vector的创建和初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1; </span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//初始化10个int类型元素</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">1.23</span>)</span></span>; <span class="comment">//初始化10个元素且初值为1.23</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(a, a + <span class="number">5</span>)</span></span>;<span class="comment">//用数组v4[0...4]共五个元素初始</span></span><br></pre></td></tr></table></figure><h3 id="8-vector成员函数"><a href="#8-vector成员函数" class="headerlink" title="8.  vector成员函数"></a>8.  vector成员函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">empyt</span>() / <span class="built_in">size</span>() / [] / <span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">reserve</span>(n); <span class="comment">//  为容器预分配n个元素的空间</span></span><br><span class="line"><span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">//翻转[first, end)之间的元素，没有返回值</span></span><br><span class="line"><span class="built_in">push_back</span>();<span class="comment">//在尾部添加一个元素</span></span><br><span class="line"><span class="built_in">insert</span>(pos, elem); <span class="comment">//元素elem插入到迭代器pos指定元素之前,</span></span><br><span class="line">如：<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + i, k, a); <span class="comment">// 在下标为i的元素前插入k个元素a</span></span><br><span class="line">v.<span class="built_in">size</span>();<span class="comment">//当前真实元素个数</span></span><br><span class="line">v.<span class="built_in">capacity</span>();<span class="comment">// 预分配的空间大小</span></span><br></pre></td></tr></table></figure><h3 id="9-vector容器大小增长规律"><a href="#9-vector容器大小增长规律" class="headerlink" title="9.  vector容器大小增长规律"></a>9.  vector容器大小增长规律</h3><blockquote><ul><li>当元素个数达到当前容量(capacity())vector会进行扩容，容纳更多元素</li><li>扩容时，vector容器会分配更大一块内存，并将原有的元素逐个复制到新的空间中。</li><li>扩容通常会导致vector容器内部重新分配内存，因此需要进行拷贝操作，影响性能。</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;lidrizzle.github.oi&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;lidrizzle</summary>
      
    
    
    
    
    <category term="STL" scheme="https://lidrizzle.github.io/lidrizzle.github.oi/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/24/STL/hello-world/"/>
    <id>https://lidrizzle.github.io/lidrizzle.github.oi/2024/05/24/STL/hello-world/</id>
    <published>2024-05-24T05:02:17.394Z</published>
    <updated>2024-05-24T05:02:17.394Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\lidrizzle.github.oi\assets\css\APlayer.min.css"><script src="\lidrizzle.github.oi\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\lidrizzle.github.oi\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;lidrizzle.github.oi&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;lidrizzle</summary>
      
    
    
    
    
  </entry>
  
</feed>
